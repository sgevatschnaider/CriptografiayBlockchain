# -*- coding: utf-8 -*-
"""Criptografía y PGP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19jhN4NBbaM1N5ru07t4jHLZYcIAnPt18
"""

# Instala la librería `cryptography` si es necesario
!pip install cryptography

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
import os

# Solicitar el mensaje original al usuario
mensaje_original = input("Ingrese el mensaje que desea cifrar: ").encode()

# Paso 1: Generar Clave de Sesión Única
clave_sesion = os.urandom(32)  # AES-256 requiere una clave de 32 bytes

# Paso 2: Cifrar Mensaje con Clave de Sesión (AES-GCM)
# Generar y almacenar el nonce antes de crear el objeto Cipher
nonce = os.urandom(12)
aes_cipher = Cipher(algorithms.AES(clave_sesion), modes.GCM(nonce), backend=default_backend())
encryptor = aes_cipher.encryptor()
mensaje_cifrado = encryptor.update(mensaje_original) + encryptor.finalize()
tag = encryptor.tag  # Almacenar la etiqueta de autenticación

# Paso 3: Generar Claves RSA (Pública y Privada)
clave_privada = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)
clave_publica = clave_privada.public_key()

# Cifrar la clave de sesión con la clave pública (RSA)
clave_sesion_cifrada = clave_publica.encrypt(
    clave_sesion,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

# Paso 4: Descifrar la Clave de Sesión con Clave Privada del Receptor
clave_sesion_descifrada = clave_privada.decrypt(
    clave_sesion_cifrada,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

# Paso 5: Aplicar Clave de Sesión al Mensaje Cifrado para Recuperar el Mensaje Original
# Asegúrate de pasar el nonce y el tag durante el descifrado
aes_cipher_descifrado = Cipher(algorithms.AES(clave_sesion_descifrada), modes.GCM(nonce, tag), backend=default_backend())
decryptor = aes_cipher_descifrado.decryptor()
mensaje_recuperado = decryptor.update(mensaje_cifrado) + decryptor.finalize()

# Mostrar los resultados
print("Mensaje Original:", mensaje_original.decode())
print("Mensaje Cifrado:", mensaje_cifrado)
print("Clave de Sesión Cifrada:", clave_sesion_cifrada)
print("Mensaje Recuperado:", mensaje_recuperado.decode())

from IPython.display import display, HTML

# Contenido HTML
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explicación de PGP y su Implementación en el Código</title>
    <style>
        /* Estilos básicos */
        body {
            font-family: 'Georgia', serif;
            line-height: 1.8;
            margin: 20px;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        /* Encabezados */
        h1, h2, h3 {
            font-family: 'Arial', sans-serif;
            color: #0066cc;
        }
        h1 {
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 20px;
        }
        h2 {
            font-size: 2em;
            margin-top: 20px;
        }
        h3 {
            font-size: 1.5em;
            margin-top: 15px;
        }
        /* Listas */
        ul {
            list-style-type: none;
            margin-left: 20px;
            margin-bottom: 20px;
        }
        li {
            font-size: 1.1em;
            margin-bottom: 10px;
            position: relative;
        }
        li::before {
            content: "🔹";
            color: #0066cc;
            font-weight: bold;
            margin-right: 8px;
            position: absolute;
            left: -20px;
        }
        /* Tarjeta */
        .card {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        /* Divider */
        .divider {
            height: 2px;
            background-color: #e0e0e0;
            margin: 30px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Explicación de PGP y su Implementación en el Código</h1>

    <div class="card">
        <h2>PGP (Pretty Good Privacy)</h2>
        <p><strong>PGP (Pretty Good Privacy)</strong> es un estándar de cifrado y autenticación utilizado principalmente para proteger la privacidad de correos electrónicos y otros datos confidenciales. Fue desarrollado por Phil Zimmermann en 1991 y ha sido ampliamente adoptado debido a su combinación de seguridad y facilidad de uso.</p>
        <p>PGP emplea un enfoque de <strong>cifrado híbrido</strong> que combina criptografía de clave simétrica (AES, DES) y criptografía de clave asimétrica (RSA, DSA) para ofrecer una comunicación segura y autenticada. Su funcionamiento básico implica los siguientes pasos:</p>
        <ul>
            <li><strong>Cifrado Simétrico:</strong> El mensaje se cifra utilizando una clave de sesión única generada aleatoriamente. Esto es eficiente y rápido.</li>
            <li><strong>Cifrado Asimétrico de la Clave de Sesión:</strong> La clave de sesión se cifra utilizando la clave pública del receptor, asegurando que solo el receptor pueda descifrarla.</li>
            <li><strong>Descifrado de la Clave de Sesión y del Mensaje:</strong> El receptor usa su clave privada para descifrar la clave de sesión y luego el mensaje.</li>
        </ul>
        <p>Este sistema ofrece tanto <strong>confidencialidad</strong> como <strong>integridad</strong> al permitir verificar si el mensaje ha sido alterado.</p>
    </div>

    <div class="divider"></div>

    <div class="card">
        <h2>Cómo el Código Aplica el Principio de PGP</h2>
        <p>El código anterior implementa un flujo similar al de PGP utilizando las bibliotecas de criptografía en Python:</p>
        <ul>
            <li><strong>Generación de la Clave de Sesión:</strong> Se genera una clave única con <code>os.urandom(32)</code> para el cifrado simétrico AES-256.</li>
            <li><strong>Cifrado del Mensaje con AES-GCM:</strong> El mensaje se cifra utilizando AES en modo GCM, generando una etiqueta de autenticación (<code>tag</code>) para verificar la integridad del mensaje cifrado.</li>
            <li><strong>Cifrado de la Clave de Sesión con RSA:</strong> La clave de sesión se cifra con una clave pública RSA, asegurando que solo el receptor pueda descifrarla.</li>
            <li><strong>Descifrado de la Clave de Sesión y del Mensaje:</strong> El receptor descifra la clave de sesión y luego el mensaje utilizando AES-GCM, verificando también la integridad del mensaje.</li>
        </ul>
    </div>

    <div class="divider"></div>

    <div class="card">
        <h2>Beneficios y Consideraciones</h2>
        <h3>Seguridad y Eficiencia</h3>
        <ul>
            <li><strong>Seguridad:</strong> El uso de una clave de sesión única y el cifrado RSA aseguran que solo el receptor legítimo puede descifrar el mensaje.</li>
            <li><strong>Eficiencia:</strong> AES es rápido y eficiente, mientras que RSA solo se usa para proteger la clave de sesión.</li>
            <li><strong>Integridad y Autenticación:</strong> La etiqueta de autenticación <code>tag</code> generada por el modo GCM permite verificar que el mensaje no ha sido modificado.</li>
        </ul>
        <p>Este flujo es muy similar al de PGP, combinando cifrado simétrico y asimétrico para proteger tanto el contenido del mensaje como la clave de sesión.</p>
    </div>
</body>
</html>
"""

# Mostrar el contenido HTML
display(HTML(html_content))