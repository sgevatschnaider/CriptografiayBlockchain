# -*- coding: utf-8 -*-
"""Criptograf铆a y PGP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19jhN4NBbaM1N5ru07t4jHLZYcIAnPt18
"""

# Instala la librer铆a `cryptography` si es necesario
!pip install cryptography

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
import os

# Solicitar el mensaje original al usuario
mensaje_original = input("Ingrese el mensaje que desea cifrar: ").encode()

# Paso 1: Generar Clave de Sesi贸n nica
clave_sesion = os.urandom(32)  # AES-256 requiere una clave de 32 bytes

# Paso 2: Cifrar Mensaje con Clave de Sesi贸n (AES-GCM)
# Generar y almacenar el nonce antes de crear el objeto Cipher
nonce = os.urandom(12)
aes_cipher = Cipher(algorithms.AES(clave_sesion), modes.GCM(nonce), backend=default_backend())
encryptor = aes_cipher.encryptor()
mensaje_cifrado = encryptor.update(mensaje_original) + encryptor.finalize()
tag = encryptor.tag  # Almacenar la etiqueta de autenticaci贸n

# Paso 3: Generar Claves RSA (P煤blica y Privada)
clave_privada = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)
clave_publica = clave_privada.public_key()

# Cifrar la clave de sesi贸n con la clave p煤blica (RSA)
clave_sesion_cifrada = clave_publica.encrypt(
    clave_sesion,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

# Paso 4: Descifrar la Clave de Sesi贸n con Clave Privada del Receptor
clave_sesion_descifrada = clave_privada.decrypt(
    clave_sesion_cifrada,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

# Paso 5: Aplicar Clave de Sesi贸n al Mensaje Cifrado para Recuperar el Mensaje Original
# Aseg煤rate de pasar el nonce y el tag durante el descifrado
aes_cipher_descifrado = Cipher(algorithms.AES(clave_sesion_descifrada), modes.GCM(nonce, tag), backend=default_backend())
decryptor = aes_cipher_descifrado.decryptor()
mensaje_recuperado = decryptor.update(mensaje_cifrado) + decryptor.finalize()

# Mostrar los resultados
print("Mensaje Original:", mensaje_original.decode())
print("Mensaje Cifrado:", mensaje_cifrado)
print("Clave de Sesi贸n Cifrada:", clave_sesion_cifrada)
print("Mensaje Recuperado:", mensaje_recuperado.decode())

from IPython.display import display, HTML

# Contenido HTML
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explicaci贸n de PGP y su Implementaci贸n en el C贸digo</title>
    <style>
        /* Estilos b谩sicos */
        body {
            font-family: 'Georgia', serif;
            line-height: 1.8;
            margin: 20px;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        /* Encabezados */
        h1, h2, h3 {
            font-family: 'Arial', sans-serif;
            color: #0066cc;
        }
        h1 {
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 20px;
        }
        h2 {
            font-size: 2em;
            margin-top: 20px;
        }
        h3 {
            font-size: 1.5em;
            margin-top: 15px;
        }
        /* Listas */
        ul {
            list-style-type: none;
            margin-left: 20px;
            margin-bottom: 20px;
        }
        li {
            font-size: 1.1em;
            margin-bottom: 10px;
            position: relative;
        }
        li::before {
            content: "";
            color: #0066cc;
            font-weight: bold;
            margin-right: 8px;
            position: absolute;
            left: -20px;
        }
        /* Tarjeta */
        .card {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        /* Divider */
        .divider {
            height: 2px;
            background-color: #e0e0e0;
            margin: 30px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Explicaci贸n de PGP y su Implementaci贸n en el C贸digo</h1>

    <div class="card">
        <h2>PGP (Pretty Good Privacy)</h2>
        <p><strong>PGP (Pretty Good Privacy)</strong> es un est谩ndar de cifrado y autenticaci贸n utilizado principalmente para proteger la privacidad de correos electr贸nicos y otros datos confidenciales. Fue desarrollado por Phil Zimmermann en 1991 y ha sido ampliamente adoptado debido a su combinaci贸n de seguridad y facilidad de uso.</p>
        <p>PGP emplea un enfoque de <strong>cifrado h铆brido</strong> que combina criptograf铆a de clave sim茅trica (AES, DES) y criptograf铆a de clave asim茅trica (RSA, DSA) para ofrecer una comunicaci贸n segura y autenticada. Su funcionamiento b谩sico implica los siguientes pasos:</p>
        <ul>
            <li><strong>Cifrado Sim茅trico:</strong> El mensaje se cifra utilizando una clave de sesi贸n 煤nica generada aleatoriamente. Esto es eficiente y r谩pido.</li>
            <li><strong>Cifrado Asim茅trico de la Clave de Sesi贸n:</strong> La clave de sesi贸n se cifra utilizando la clave p煤blica del receptor, asegurando que solo el receptor pueda descifrarla.</li>
            <li><strong>Descifrado de la Clave de Sesi贸n y del Mensaje:</strong> El receptor usa su clave privada para descifrar la clave de sesi贸n y luego el mensaje.</li>
        </ul>
        <p>Este sistema ofrece tanto <strong>confidencialidad</strong> como <strong>integridad</strong> al permitir verificar si el mensaje ha sido alterado.</p>
    </div>

    <div class="divider"></div>

    <div class="card">
        <h2>C贸mo el C贸digo Aplica el Principio de PGP</h2>
        <p>El c贸digo anterior implementa un flujo similar al de PGP utilizando las bibliotecas de criptograf铆a en Python:</p>
        <ul>
            <li><strong>Generaci贸n de la Clave de Sesi贸n:</strong> Se genera una clave 煤nica con <code>os.urandom(32)</code> para el cifrado sim茅trico AES-256.</li>
            <li><strong>Cifrado del Mensaje con AES-GCM:</strong> El mensaje se cifra utilizando AES en modo GCM, generando una etiqueta de autenticaci贸n (<code>tag</code>) para verificar la integridad del mensaje cifrado.</li>
            <li><strong>Cifrado de la Clave de Sesi贸n con RSA:</strong> La clave de sesi贸n se cifra con una clave p煤blica RSA, asegurando que solo el receptor pueda descifrarla.</li>
            <li><strong>Descifrado de la Clave de Sesi贸n y del Mensaje:</strong> El receptor descifra la clave de sesi贸n y luego el mensaje utilizando AES-GCM, verificando tambi茅n la integridad del mensaje.</li>
        </ul>
    </div>

    <div class="divider"></div>

    <div class="card">
        <h2>Beneficios y Consideraciones</h2>
        <h3>Seguridad y Eficiencia</h3>
        <ul>
            <li><strong>Seguridad:</strong> El uso de una clave de sesi贸n 煤nica y el cifrado RSA aseguran que solo el receptor leg铆timo puede descifrar el mensaje.</li>
            <li><strong>Eficiencia:</strong> AES es r谩pido y eficiente, mientras que RSA solo se usa para proteger la clave de sesi贸n.</li>
            <li><strong>Integridad y Autenticaci贸n:</strong> La etiqueta de autenticaci贸n <code>tag</code> generada por el modo GCM permite verificar que el mensaje no ha sido modificado.</li>
        </ul>
        <p>Este flujo es muy similar al de PGP, combinando cifrado sim茅trico y asim茅trico para proteger tanto el contenido del mensaje como la clave de sesi贸n.</p>
    </div>
</body>
</html>
"""

# Mostrar el contenido HTML
display(HTML(html_content))